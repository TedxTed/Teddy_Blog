# 第二部分 測試驅動開發過程 CH6 面向對象風格
###### tags: `測試驅動的面向對象軟件開發`

49
## 簡介
- 容易維護的代碼，價值遠超過容易編寫的代碼
## 為可維護而設計
- 我們每次只實現系統的一項功能
- 隨者代碼增加，若希望能夠理解和維護他-> 即將功能組織到對象中，將對象組知道模塊庫中，將模塊庫組知道程序中，將程序組職到系統中
- 關注點分離
    - 當必須改變系統時，我們希望代碼的修改盡可能少
    - 如果相關改動都只在一部分代碼中，就不必到各處找需要完成的工作
    - 因為不能預測何時需要星改系統的哪一部分代碼，所以我們將因相同原因而需要修改的代碼放在一起
- 更高的抽象層次
    - 人們對複雜性的唯一方法就是利用更高的抽象繩是避免他
    - 與操縱變涼和控制流相比，如果通過組合來實現有用的功能的組件來編程，我們就可以做更多事 ex：人們會按照菜單點菜，而不是深入了解做菜的配方的細節
- 一致的應用上述兩點，應用的結構就會朝者“端口與適配器”架構發展
    - 業務領域的代碼與他依賴的技術基礎設施是分離的，我們不希望技術概念溜進應用模型中，所以編寫了一些接口，用他的術語來描述他與外部世界之間的關係
- 封裝
    - 確保只能透過對象的API來影響對象的行為，這確保了不相關的對象之間沒有未預料到依賴關係，從而讓我們能狗控制一個對象的修改對系統其他部分的影響程度
- 信息隱藏
    - 隱藏了對象在API抽象之後的實現其功能的方式
    - 當面對封裝糟糕的代碼，我們就會花很多時間去跟蹤變更可能產生的影響
        - 尋找對象在哪裡被創建
        - 他保存了哪些共用的數據
        - 他們內容在哪裡被引用
    - 編寫代碼時，遵循一些標準實踐來保持封裝
        - 定義不可修改的值類型
        - 避免全局變量
        - 避免單例模式（singleton）
        - 通過複製集合和可修改的值，在對象間實現傳遞
## 內部與同級的比較
- 組織系統時
    - 必須決定什麼在某個對象內，什麼再他之外 ->這樣對象就能利用清晰的API提供一致的抽象
    - 對象的要點在於通過API來封裝對他內部的訪問，並向系統其他部分隱藏這些細節
    - 對象通過發送消息與系統其他對象實現通信
## 沒有"與","或","但是"
- 每個對象都有單一的，清楚定義的職責，這就是“單一職責”
- 當我們為系統添加行為時，這個原則幫助我們決定是擴展一個已有的對象，還是創建一個新的服務供對象調用
- 不使用任何連詞（"與","或"）就能夠描述一個對象
- 當我們發現我們描述增加了從句，那就代表對象應該分解為幾個協作的對象，通常每個從句對應一個對象
## 對象同級夠造型
我們有一些職責單一的對象，與他們同級通過清晰API所定義的消息進行通訊，他們彼此說什麼
 - 依賴關係
     - 對象向他的同級請求服務，這樣對象就能實現它的職責，沒有這些服務，對象就不能夠工作，應該不用創建這個對象
 - 通知關係
     - 同級對象需要了解對象的活動，當對象改變狀態或執行一個重要的操作時，他將通知感興趣的同級對象
     - 通知是“發出就忘記”，對象不知道也不關心哪些同級對象在監聽
     - 通知非常有用->因為他解除了對象之間的耦合（用戶介面系統，按下時通知所有註冊的監聽者，但他不知道這些監聽者會做什麼）
 - 調整關係
     - 同級對象會調整該對象的行為，以適應系統更多的需求
     - 這包括代替對象做出決定的策略對象，也包括組合對象的組件部分
 - 通知是單向的，通知監聽者不能夠返回一個值，也不能條用回朔或拋出異常，因為在後面可能還有其他監聽者，依賴和調整則可以做這些事，因為存在直接關係
## 組合比他的部分之和更簡單
- 當把一些對象組合成一個新類型時，會希望新的類型所表現出來的行為比所有組成的行為之和更簡單
- 複合對象的API必須隱藏其組成不燜的存在，並隱藏他們的交互，向他的同級對象暴露出更簡單的抽象
## 上下文無關注
- 組合比他的部分之和更簡單：這條規則幫助我們決定對象是否隱藏了足夠多的信息
- 上下文無關注：這條規則幫助我們決定是否隱藏太多信息或錯誤的信息
    - 每個對象都沒有再內部包含他所在系統的知識
    - 這下我們能夠取出一組行為（對象），並將他用於新的情況
    - 要做到上下文無關，對象所需知道的運行更大的環境訊息，就必須被傳入對象
## 正確地隱藏信息

## 固執已見的觀點
