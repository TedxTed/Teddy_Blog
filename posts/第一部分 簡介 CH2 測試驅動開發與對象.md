# 第一部分 簡介 CH2 測試驅動開發與對象
###### tags: `測試驅動的面向對象軟件開發`

26

## 2.1 對象與網
- 面對對象設計更關注對象之間的通信，而非對象本身，重要思想是“發送訊息”
- 對象利用消息進行通信
- 對象會封裝一些內部狀態，他利用這些內部狀態來協調與其他對象的通信
- 面向對象系統是一些協作對象組成的網，系統的建造方法是創建一些對象，並將他們組裝再一起，讓他們可以相互發送訊息
- 讓我們能夠改變對象組合來改變系統行為（添加或刪除實例，進行不同的組裝），而不是編寫過程式代碼
- 管理這種組合而寫的代碼是聲明是的定義
    - 決定對象之網的行為模式
    - 改變系統更方便
    - 可以更專注於我們想讓他做什麼，而不是怎麼做
## 2.2 值與對象
- 設計一個系統時，重要的是區別值(value)和對象(object)
    - 值是不變的數量或測量結果的模型
    - 對象是唯一標示符，可以隨時間改變狀態，是對計算過程的模型
## 2.3 對象通信
- 只有當對象設計容易組合時，聲明式的方式才能獲利
- 這意味者，他們遵循相同通信模式，並且依賴關係是顯式的
- 通信模式是一組機制
    - 決定一組對象相互交談模式，這些規則包含他們扮演的角色
    - 他們可以發送什麼消息
    - 何時可以發送
- 在一個遊戲中，對象可能包括
    - 參與者(玩家或敵人)
    - 場景（玩家飛過的環境）
    - 障礙（玩家遇上就會撞毀）
    - 效果（如爆炸和煙霧）
    - ![](https://i.imgur.com/XQvQUEN.png)
- 角色，職責，協作者
    - 對象實現了一過或多個角色，
    - 角色是一組相關職責，
    - 職責有執行任務或知道信息的義務
    - 協作是對象或角色的交互
    - ![](https://i.imgur.com/JesTHkX.png)

## 2.4 吩咐，不要問
- 設計一些對象，他們互相發送消息
- 正在調用的對象應該根據鄰居扮演角色來描述他的要求，讓被調用的對象來決定該如何實現
- 吩咐，不要問！！
- 調用者看不到被調用者內部的結構，也看不到隱藏在角色接口後面的，系統其他部分的結構
- 若不遵守這個規則，很容易得到火車殘骸的代碼
    - object.doA.doB.doC.save
## 2.5 但有時要問
- 有時候，我們在搜索或過濾時也詢問對象狀態
- 我們應該詢問真正希望得到答案的問題，而不是問那些可以幫助我們猜出答案的信息
    - 要問是否能分散座位
    - 不要問有幾節包廂，有什麼種類的座位再去自己猜能不能分散座位
- 添加一個查詢方法，這將行為移到最適合的對象，給他一個解釋行名稱，並使它更容易測試
- 我們要試圖謹慎的查詢對象
    - 因為查詢可能會“洩漏”對象的信息
    - 使系統僵硬
    - 要強調逼寫查詢時要描述條用對象的意圖，而不僅僅是實現
## 2.6 對協作的對象執行單元測試
- 我們堅持關注對象
    - 這些對象相互發送命令
    - 並不提供任好方式來暴露他們的狀態
- 在測試中用替代對象及模擬對象來代替目標對象的鄰居
- 規定 過處發事件後，預期目標對象與他的模擬鄰居會如何通信->這些規定稱為“預期”
- 模擬對象會斷言他們會預期那樣被調用，同時他們也會實現一些樁行為
- 梳理
    - 只是嘗試測試目標對象
    - 我們已經知道他的鄰居長什麼樣子，且在編寫測試時這些協作者不需要存在
    - 我們可以利用測試來幫助我們梳理對象所需支持的角色
## 2.7 用模擬對象支持TDD
- 我們需要創建鄰居對象的一些模擬實例，定義他們被調用的預期，實現完成測試所需要的行為
- 使用術語“mockery”來指這一種對象，他保存測試的上下文，為測試創建模擬對象，管理預期和行為實現

## 測試的基本結構
- 創建所有要求的模擬對象
- 創建所有真正的對象，包括目標對象
- 規定你預期目標對象將怎麼條用模擬對象
- 在目標對象上調用觸發方法
- 斷言所有結果預期是有效的，並且所有預期的調用都發生了

## 小結
- 單元測試明確了目標對象與環境的關係
- 創建了一組對象，並對目標對象其協作者之間的交互進行斷言
- 要點在於
    - 弄清楚每個測試的意圖
    - 區分被測試的功能，支持的基礎設施和對象的結構